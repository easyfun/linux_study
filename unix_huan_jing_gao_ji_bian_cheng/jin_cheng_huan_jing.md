####UNIX环境高级编程（第二版）

####第7章 进程环境

7.2 main函数<br/>

C程序的启动过程<br/>
内核调用exec函数执行程序（可执行文件）<br/>
调用程序的启动例程（由编译器生成）<br/>
调用main函数<br/>

7.3 进程终止<br/>
正常终止：<br/>
    从main返回<br/>
    调用exit<br/>
    调用_exit或_Exit<br/>
    最后一个线程从启动例程返回<br/>
    最后一个线程调用pthread_exit<br/>

异常终止：<br/>
    调用abort<br/>
    接到一个信号并终止<br/>
    最后一个线程对取消请求做出响应<br/>

**注意**，内核使程序执行的唯一方法是调用exec函数。进程终止的方法是显示调用或者隐试调用（exit）_exit或_Exit，也可非自愿的由一个信号使其终止<br/>


7.6 C程序的存储空间布局<br/>
程序分段：<br/>
    正文段<br/>
    初始化数据段<br/>
    非初始化数据段<br/>
    栈<br/>
    堆<br/>

7.8 存储器分配<br/>
linux存储器系统函数<br/>
sbrk(2)

ISO C存储函数<br/>
malloc<br/>
calloc<br/>
realloc  可增减存储区长度，增加时内存重新分配，内存数据复制 <br/>

在linux下，mallc，calloc，realloc内部使用sbrk系统调用实现<br/>
大多数实现所分配的存储空间比要求的大一点，用于保存管理信息——分配块的长度，指向下一个分配块指针等等<br/>

注意：<br/>
不要在用户层分块块以外写数据，很可能破坏程序上下文<br/>
free一个已经释放的块，释放不是三个alloc函数返回的指针，会引起程序崩溃<br/>
malloc，calloc，realloc申请的内存用完后，要释放，避免内存泄漏。内存泄漏，使可用（虚拟）内存越来越少<br/>

也有很好的替代程序<br/>



####第八章 进程控制
进程的资源：<br/>
实际用户ID，实际组ID，有效用户ID，有效组ID<br/>
附加组ID<br/>
进程组ID<br/>
会话ID<br/>
设置用户ID标志，设置组ID标志<br/>
命令行参数表<br/>
环境参数表<br/>
当前工作目录<br/>
根目录<br/>
控制终端<br/>
文件表述符表（标准输入，标准输出，标准出错）<br/>
文件模式创建屏蔽字<br/>
信号屏蔽和安排<br/>
针对任一打开文件描述符的在执行时关闭标志<br/>
连接的共享存储段<br/>
存储映射<br/>
运行时间<br/>

8.2 进程标识符<br/>
在系统中唯一，可以重用（足够长时间后），线程ID在进程中唯一<br/>
调度进程(交换进程），ID为0，内核创建的进程，系统进程<br/>

init进程，ID为1，普通用户进程，所有者是超级用户。读取与系统初始化文件，引导系统到一个状态（多用户）。自动成为孤儿进程的父进程<br/>

页守护进程，ID为2，内核进程。<br/>

8.3 fork函数<br/>
没有系统函数获取父进程的所有子进程ID<br/>

strlen进行一次函数调用<br/>
sizeof编译时计算<br/>

read，write等文件I/O系统调用函数，不带缓存。
标准I/O函数带缓存。<br/>
    对文件，默认全缓存<br/>
    对标准终端，默认行缓存<br/>



8.3 fork函数<br/>
创建子进程，子进程会继承非常多的特性，拷贝一份副本<br/>

父子进程的区别：<br/>
    fork的返回值<br/>
    进程ID不一样，各自的父进程ID也不一样<br/>
    子进程的tms_utime,tms_stime,tms_cutime以及tms_ustime均设置为0<br/>
    父进程设置的文件锁不会被子进程继承<br/>
    子进程的未处理的闹钟被清除<br/>
    子进程的未处理的信号集设置为空集<br/>

fork的两种用法:<br/>
（1）创建一个子进程执行新的任务<br/>
（2）创建一个子进程执行新的程序<br/>


8.5 exit函数<br/>
**退出状态**,传递给exit，_exit，_Exit的参数，或main函数的返回值<br/>
**终止状态**,_exit或_Exit调用中，内核将退出状态转换程终止状态，表示进程是正常终止，还是异常终止<br/>

exit函数：<br/>
    调用exit处理程序<br/>
    关闭标准库I/O流（冲洗缓存）<br/>
exit，_exit，_Exit
    进一步的终止清理，关闭所有打开的描述符，释放存储器<br/>
**注意**，直接调用_exit，_Exit，可能出现文件写丢失<br/>

父进程fork子进程，父进程先终止，init进程领养其子进程<br/>
子进程先终止，父进程不检查子进程的终止状态做相关清理，子进程编程僵死进程，init的子进程不会成为僵死进程,ps命令显示为Z状态<br/>

**僵死进程**，一个已经终止，父进程未其进行善后处理（获取子进程的终止状态，释放它占用的资源）的进程<br/>
进程调用exit，_exit，_Exit终止，并没有完全销毁，会留下一个僵死进程的数据结构，共父进程检查其终止状态<br/>

**僵死进程的危害**<br/>
父进程不调用wait/waitpid，保留的数据信息不会被释放，其进程号会被占用着。系统可使用的进程号是有限的，僵死进程过多，会导致系统不能产生新的进程<br/>

**僵死进程的避免**<br/>
1.父进程通过wait/waitpid等函数等待子进程结束，父进程会挂起<br/>
2.如果父进程很忙，可以用signal函数为SIGCHLD安装信号处理函数。子进程结束后，父进程会收到这个信号，在信号处理函数中调用wait回收。<br/>
3.如果父进程不关心子进程终止状态，可以用signal(SIGCHLD,SIG_IGN)通知内核，自己忽略子进程的终止状态。子进程结束后，内核回收，并不再给父进程发送信号。
或者用sigaction函数注册对SIGCHLD消息的忽略处理<br/>
4.fork两次，父进程fork一个子进程，子进程fork一个子孙进程后立即退出。子孙进程被init进程接管，子孙进程结束后，由init回收。子进程退出得父进程负责处理<br/>

     nStatus;
     pid_t pid;
        
     pid = vfork();            //生成子进程
     if (pid > 0)            //父进程
     {
        waitpid(pid, &nStatus, 0);    //等待子进程结束,否则子进程会成为僵死进程,一直存在,即便子进程已结束执行
     }
     else if (0 == pid)        //子进程
     {
        pid = vfork();        //生成孙进程
        if (pid > 0)
        {
        	exit(0);        //子进程退出,孙进程过继给init进程,其退出状态也由init进程处理,与原有父进程无关
       	}
	    else if (0 == pid)    //孙进程
       	{
            if (execlp("ls", "ls", NULL) < 0)
            {
                perror("execlp");
                exit(-1);
            }
        }
        else
        {
            perror("vfork(child)");
        }
    }
    else
    {
       perror("vfork(parent)");
    }





































